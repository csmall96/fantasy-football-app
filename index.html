<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Football Hub</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS Variables for Theming */
        :root {
            --primary-gradient-from: #6366f1;
            --primary-gradient-via: #9333ea;
            --primary-gradient-to: #ec4899;
            --card-bg: rgba(255, 255, 255, 0.95);
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
        }

        /* Custom Animations */
        @keyframes slideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .animate-slide-in {
            animation: slideIn 0.3s ease-out;
        }

        /* Loading Spinner Enhancement */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid white;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Glass Morphism Effects */
        .glass-morphism {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(147, 51, 234, 0.5);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(147, 51, 234, 0.7);
        }

        .hover-scale-102:hover {
            transform: scale(1.02);
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        // ============================================
        // CONFIGURATION & CONSTANTS
        // ============================================
        const CONFIG = {
            SLEEPER_LEAGUE_ID: "1257104566718042112",
            // Note: OpenAI API key not needed in frontend - only used in build script
            API_BASE_URL: "https://api.sleeper.app/v1",
            CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
            HISTORICAL_LEAGUES: {
                2024: "1124834179272417280",
                2023: "999002709053255680",
                2022: "873232652768088064"
            }
        };MsyI_bOguL3lA0Z1mFgSCTx5EA",
            API_BASE_URL: "https://api.sleeper.app/v1",
            CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
            HISTORICAL_LEAGUES: {
                2024: "1124834179272417280",
                2023: "999002709053255680",
                2022: "873232652768088064"
            }
        };

        // ============================================
        // UTILITY FUNCTIONS & HELPERS
        // ============================================
        const Utils = {
            // Cache management
            cache: new Map(),
            
            async cachedFetch(url, cacheKey = null) {
                const key = cacheKey || url;
                const cached = this.cache.get(key);
                
                if (cached && Date.now() - cached.timestamp < CONFIG.CACHE_DURATION) {
                    return cached.data;
                }
                
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                const data = await response.json();
                
                this.cache.set(key, { data, timestamp: Date.now() });
                return data;
            },

            // Format numbers with appropriate precision
            formatNumber(num, decimals = 1) {
                return Number(num).toFixed(decimals);
            },

            // Group array by key
            groupBy(array, key) {
                return array.reduce((result, item) => {
                    const group = item[key];
                    if (!result[group]) result[group] = [];
                    result[group].push(item);
                    return result;
                }, {});
            },

            // Sort by multiple fields
            sortBy(array, ...fields) {
                return [...array].sort((a, b) => {
                    for (const field of fields) {
                        const aVal = typeof field === 'function' ? field(a) : a[field];
                        const bVal = typeof field === 'function' ? field(b) : b[field];
                        if (aVal !== bVal) return aVal > bVal ? 1 : -1;
                    }
                    return 0;
                });
            }
        };

        // ============================================
        // SLEEPER API SERVICE
        // ============================================
        class SleeperAPI {
            static async getLeague(leagueId = CONFIG.SLEEPER_LEAGUE_ID) {
                return Utils.cachedFetch(`${CONFIG.API_BASE_URL}/league/${leagueId}`);
            }

            static async getUsers(leagueId = CONFIG.SLEEPER_LEAGUE_ID) {
                return Utils.cachedFetch(`${CONFIG.API_BASE_URL}/league/${leagueId}/users`);
            }

            static async getRosters(leagueId = CONFIG.SLEEPER_LEAGUE_ID) {
                return Utils.cachedFetch(`${CONFIG.API_BASE_URL}/league/${leagueId}/rosters`);
            }

            static async getMatchups(leagueId, week) {
                return Utils.cachedFetch(`${CONFIG.API_BASE_URL}/league/${leagueId}/matchups/${week}`);
            }

            static async getTransactions(leagueId, week) {
                try {
                    return await Utils.cachedFetch(`${CONFIG.API_BASE_URL}/league/${leagueId}/transactions/${week}`);
                } catch (e) {
                    return [];
                }
            }

            static async getPlayers() {
                return Utils.cachedFetch(`${CONFIG.API_BASE_URL}/players/nfl`, 'nfl-players');
            }

            static async getPlayoffBracket(leagueId) {
                try {
                    return await Utils.cachedFetch(`${CONFIG.API_BASE_URL}/league/${leagueId}/winners_bracket`);
                } catch (e) {
                    return null;
                }
            }
        }

        // ============================================
        // DATA PROCESSORS
        // ============================================
        class DataProcessor {
            static processRosterData(roster, matchupData, players) {
                const starters = matchupData?.starters || [];
                const bench = roster.players ? roster.players.filter(p => !starters.includes(p)) : [];
                
                const processPlayer = (playerId) => {
                    const player = players[playerId];
                    if (!player) {
                        return {
                            id: playerId,
                            name: `Unknown (${playerId})`,
                            position: 'UNKNOWN',
                            team: null,
                            status: 'Unknown'
                        };
                    }
                    
                    const roastLevel = this.calculateRoastLevel(player);
                    
                    return {
                        id: playerId,
                        name: player.full_name,
                        position: player.position,
                        team: player.team,
                        status: player.injury_status || 'Healthy',
                        age: player.age,
                        yearsExp: player.years_exp,
                        searchRank: player.search_rank,
                        depthOrder: player.depth_chart_order,
                        roastLevel,
                        roastCategory: this.getRoastCategory(player, roastLevel),
                        isAging: (player.age || 0) >= 32,
                        isRookie: (player.years_exp || 0) <= 1,
                        injuryRisk: player.injury_status && player.injury_status !== 'Healthy'
                    };
                };
                
                return {
                    ...roster,
                    starters: starters.map(processPlayer),
                    bench: bench.map(processPlayer)
                };
            }

            static calculateRoastLevel(player) {
                if (!player) return 0;
                let score = 0;
                
                if (player.age >= 32) score++;
                if (player.age >= 35) score++;
                if ((player.search_rank || 0) > 1000) score++;
                if ((player.search_rank || 0) > 2000) score++;
                if ((player.depth_chart_order || 1) >= 3) score++;
                if ((player.depth_chart_order || 1) >= 4) score++;
                if ((player.years_exp || 0) > 8 && (player.search_rank || 0) > 500) score++;
                if (player.injury_status && player.injury_status !== 'Healthy') score++;
                
                return Math.min(score, 4);
            }

            static getRoastCategory(player, level) {
                if (level === 0) return null;
                if (level === 1) return "QUESTIONABLE";
                
                const age = player?.age || 0;
                const searchRank = player?.search_rank || 0;
                const depthOrder = player?.depth_chart_order || 1;
                const yearsExp = player?.years_exp || 0;
                
                if (searchRank > 1000 && age >= 28) return "WASHED NOBODY";
                if (depthOrder >= 3) return "DEPTH CHART SCRUB";
                if (yearsExp > 8 && searchRank > 500) return "VETERAN PAYCHECK COLLECTOR";
                if (level >= 3) return "DESPERATION PLAY";
                if (level >= 4) return "FANTASY GRAVEYARD";
                
                return "RISKY START";
            }

            static processManagerData(roster, user, weeklyScores, allWeekScores) {
                const wins = roster.settings?.wins || 0;
                const losses = roster.settings?.losses || 0;
                const pointsFor = roster.settings?.fpts || 0;
                const faabUsed = roster.settings?.waiver_budget_used || 0;
                
                const userWeeklyScores = weeklyScores[roster.roster_id] || [];
                const last3 = userWeeklyScores.slice(-3);
                const last3Avg = last3.length > 0 ? 
                    last3.reduce((sum, w) => sum + w.points, 0) / last3.length : 0;
                
                // Calculate streak
                let streak = 0, streakType = 'none';
                if (userWeeklyScores.length > 0) {
                    const sorted = [...userWeeklyScores].sort((a, b) => b.week - a.week);
                    let lastResult = null;
                    
                    for (const score of sorted) {
                        const oppScore = weeklyScores[score.opponent]?.find(s => s.week === score.week)?.points || 0;
                        const won = score.points > oppScore;
                        
                        if (lastResult === null) {
                            lastResult = won;
                            streak = 1;
                            streakType = won ? 'win' : 'loss';
                        } else if (won === lastResult) {
                            streak++;
                        } else {
                            break;
                        }
                    }
                }
                
                return {
                    ...user,
                    roster_id: roster.roster_id,
                    wins,
                    losses,
                    record: `${wins}-${losses}`,
                    pointsFor: Utils.formatNumber(pointsFor),
                    faabRemaining: Math.max(0, 100 - faabUsed),
                    teamName: roster.metadata?.team_name || 
                             roster.settings?.team_name || 
                             user.metadata?.team_name || 
                             `${user.display_name}'s Team`,
                    playoffPosition: wins >= 5 ? 'in' : wins >= 3 ? 'bubble' : 'out',
                    last3Average: Utils.formatNumber(last3Avg),
                    currentStreak: streak,
                    streakType,
                    starters: roster.starters || [],
                    bench: roster.bench || []
                };
            }
        }

        // ============================================
        // CUSTOM HOOKS
        // ============================================
        const useLeagueData = () => {
            const [data, setData] = React.useState(null);
            const [loading, setLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const [loadingStatus, setLoadingStatus] = React.useState('');

            React.useEffect(() => {
                fetchLeagueData();
            }, []);

            const fetchLeagueData = async () => {
                try {
                    setLoadingStatus('Fetching league data...');
                    
                    // Fetch core league data
                    const [league, users, rosters, players] = await Promise.all([
                        SleeperAPI.getLeague(),
                        SleeperAPI.getUsers(),
                        SleeperAPI.getRosters(),
                        SleeperAPI.getPlayers()
                    ]);

                    const currentWeek = league.settings?.leg || 1;
                    
                    setLoadingStatus('Loading matchups...');
                    const currentMatchups = await SleeperAPI.getMatchups(CONFIG.SLEEPER_LEAGUE_ID, currentWeek);
                    
                    // Process rosters with matchup data
                    setLoadingStatus('Processing rosters...');
                    const detailedRosters = rosters.map(roster => {
                        const matchupData = currentMatchups.find(m => m.roster_id === roster.roster_id);
                        return DataProcessor.processRosterData(roster, matchupData, players);
                    });

                    // Calculate weekly scores
                    setLoadingStatus('Loading historical data...');
                    const weeklyScores = {};
                    const allWeekScores = {};
                    
                    for (let week = 1; week < currentWeek; week++) {
                        try {
                            const weekMatchups = await SleeperAPI.getMatchups(CONFIG.SLEEPER_LEAGUE_ID, week);
                            allWeekScores[week] = weekMatchups.map(m => ({
                                roster_id: m.roster_id,
                                points: m.points || 0
                            }));
                            
                            // Process matchups into weekly scores
                            weekMatchups.forEach(m => {
                                if (!weeklyScores[m.roster_id]) weeklyScores[m.roster_id] = [];
                                weeklyScores[m.roster_id].push({
                                    week,
                                    points: m.points || 0,
                                    projected: m.points_projected || 0,
                                    opponent: m.matchup_id // Will need to resolve this
                                });
                            });
                        } catch (e) {
                            console.error(`Error loading week ${week}:`, e);
                        }
                    }

                    // Process managers
                    const managers = detailedRosters.map(roster => {
                        const user = users.find(u => u.user_id === roster.owner_id) || {
                            user_id: roster.owner_id,
                            display_name: 'Unknown Manager'
                        };
                        return DataProcessor.processManagerData(roster, user, weeklyScores, allWeekScores);
                    });

                    // Process matchups into games
                    const matchupGroups = Utils.groupBy(currentMatchups, 'matchup_id');
                    const games = Object.values(matchupGroups)
                        .filter(pair => pair.length === 2)
                        .map((pair, index) => {
                            const team1 = managers.find(m => m.roster_id === pair[0].roster_id);
                            const team2 = managers.find(m => m.roster_id === pair[1].roster_id);
                            
                            return {
                                id: `game-${index + 1}`,
                                team1: {
                                    manager: team1?.display_name,
                                    teamName: team1?.teamName,
                                    record: team1?.record,
                                    projected: pair[0].points_projected || 0,
                                    roster_id: team1?.roster_id,
                                    starters: team1?.starters || [],
                                    bench: team1?.bench || [],
                                    last3Average: team1?.last3Average || 0,
                                    currentStreak: team1?.currentStreak || 0,
                                    streakType: team1?.streakType || 'none',
                                    playoffPos: team1?.playoffPosition || 'out'
                                },
                                team2: {
                                    manager: team2?.display_name,
                                    teamName: team2?.teamName,
                                    record: team2?.record,
                                    projected: pair[1].points_projected || 0,
                                    roster_id: team2?.roster_id,
                                    starters: team2?.starters || [],
                                    bench: team2?.bench || [],
                                    last3Average: team2?.last3Average || 0,
                                    currentStreak: team2?.currentStreak || 0,
                                    streakType: team2?.streakType || 'none',
                                    playoffPos: team2?.playoffPosition || 'out'
                                }
                            };
                        });

                    // Fetch recent transactions
                    setLoadingStatus('Loading transactions...');
                    const transactions = [];
                    for (let week = Math.max(1, currentWeek - 3); week <= currentWeek; week++) {
                        const weekTxns = await SleeperAPI.getTransactions(CONFIG.SLEEPER_LEAGUE_ID, week);
                        transactions.push(...weekTxns);
                    }

                    setData({
                        league,
                        managers,
                        games,
                        transactions,
                        currentWeek,
                        players
                    });

                } catch (err) {
                    console.error('Error fetching league data:', err);
                    setError(err.message);
                } finally {
                    setLoading(false);
                    setLoadingStatus('');
                }
            };

            return { data, loading, error, loadingStatus, refetch: fetchLeagueData };
        };

        // ============================================
        // UI COMPONENTS
        // ============================================
        
        // Loading Component
        const LoadingScreen = ({ status }) => (
            <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-800 flex items-center justify-center">
                <div className="text-center text-white">
                    <div className="loading-spinner mx-auto mb-4"></div>
                    <p className="text-xl mb-2">Loading Fantasy Hub...</p>
                    {status && <p className="text-sm text-purple-300">{status}</p>}
                </div>
            </div>
        );

        // Error Component
        const ErrorScreen = ({ error, onRetry }) => (
            <div className="min-h-screen bg-gradient-to-br from-red-900 to-red-700 flex items-center justify-center">
                <div className="text-center text-white p-8 glass-morphism rounded-xl">
                    <h1 className="text-4xl font-bold mb-4">Error Loading Data</h1>
                    <p className="mb-6 text-red-200">{error}</p>
                    <button 
                        onClick={onRetry}
                        className="bg-white text-red-900 px-6 py-3 rounded-lg hover:bg-red-100 transition-colors"
                    >
                        Try Again
                    </button>
                </div>
            </div>
        );

        // Navigation Component
        const Navigation = ({ activeView, onViewChange, leagueName, currentWeek }) => (
            <div className="glass-morphism border-b border-white border-opacity-20 sticky top-0 z-40">
                <div className="max-w-7xl mx-auto px-4 py-4">
                    <div className="flex flex-col md:flex-row justify-between items-center">
                        <div className="mb-4 md:mb-0">
                            <h1 className="text-3xl font-bold text-white">Fantasy Hub</h1>
                            <p className="text-purple-200 text-sm">{leagueName} • Week {currentWeek}</p>
                        </div>
                        <nav className="flex space-x-2">
                            {['matchups', 'standings', 'transactions', 'insights'].map(view => (
                                <button
                                    key={view}
                                    onClick={() => onViewChange(view)}
                                    className={`px-4 py-2 rounded-lg transition-all ${
                                        activeView === view
                                            ? 'bg-white text-purple-900 font-semibold'
                                            : 'text-white hover:bg-white hover:bg-opacity-20'
                                    }`}
                                >
                                    {view.charAt(0).toUpperCase() + view.slice(1)}
                                </button>
                            ))}
                        </nav>
                    </div>
                </div>
            </div>
        );

        // Matchup Card Component
        const MatchupCard = ({ game, onSelect, isGenerating }) => (
            <div 
                onClick={() => onSelect(game)}
                className="bg-white rounded-xl p-6 shadow-lg hover:shadow-xl transition-all cursor-pointer hover-scale-102 animate-slide-in"
            >
                <div className="space-y-4">
                    {/* Team 1 */}
                    <div className="border-l-4 border-blue-500 pl-4">
                        <div className="flex justify-between items-center">
                            <h3 className="font-bold text-gray-800">{game.team1.teamName}</h3>
                            <span className="text-sm text-gray-600">{game.team1.record}</span>
                        </div>
                        <p className="text-sm text-gray-500">{game.team1.manager}</p>
                        <div className="flex items-center space-x-3 text-xs text-gray-400 mt-1">
                            <span>Proj: {Utils.formatNumber(game.team1.projected)}</span>
                            {game.team1.starters.length > 0 && (
                                <span className="text-green-600">✓ Lineup Set</span>
                            )}
                            {game.team1.currentStreak > 1 && (
                                <span className={game.team1.streakType === 'win' ? 'text-green-600' : 'text-red-600'}>
                                    {game.team1.currentStreak}{game.team1.streakType === 'win' ? 'W' : 'L'}
                                </span>
                            )}
                        </div>
                    </div>

                    <div className="text-center text-gray-400 font-bold">VS</div>

                    {/* Team 2 */}
                    <div className="border-l-4 border-red-500 pl-4">
                        <div className="flex justify-between items-center">
                            <h3 className="font-bold text-gray-800">{game.team2.teamName}</h3>
                            <span className="text-sm text-gray-600">{game.team2.record}</span>
                        </div>
                        <p className="text-sm text-gray-500">{game.team2.manager}</p>
                        <div className="flex items-center space-x-3 text-xs text-gray-400 mt-1">
                            <span>Proj: {Utils.formatNumber(game.team2.projected)}</span>
                            {game.team2.starters.length > 0 && (
                                <span className="text-green-600">✓ Lineup Set</span>
                            )}
                            {game.team2.currentStreak > 1 && (
                                <span className={game.team2.streakType === 'win' ? 'text-green-600' : 'text-red-600'}>
                                    {game.team2.currentStreak}{game.team2.streakType === 'win' ? 'W' : 'L'}
                                </span>
                            )}
                        </div>
                    </div>

                    <div className="text-center pt-2">
                        {isGenerating ? (
                            <span className="text-sm text-purple-600 animate-pulse">Generating analysis...</span>
                        ) : (
                            <span className="text-sm text-purple-600 hover:text-purple-800">
                                Click for analysis →
                            </span>
                        )}
                    </div>
                </div>
            </div>
        );

        // Matchup Modal Component
        const MatchupModal = ({ game, preview, onClose }) => (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                <div className="bg-white rounded-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto animate-slide-in">
                    <div className="sticky top-0 bg-white border-b p-6 flex justify-between items-start">
                        <div>
                            <h2 className="text-2xl font-bold text-gray-800">Commissioner Analysis</h2>
                            <p className="text-gray-600">{game.team1.teamName} vs {game.team2.teamName}</p>
                        </div>
                        <button 
                            onClick={onClose}
                            className="text-gray-500 hover:text-gray-700 text-2xl leading-none"
                        >
                            ×
                        </button>
                    </div>

                    <div className="p-6">
                        {preview ? (
                            <div className="prose max-w-none">
                                <div className="whitespace-pre-wrap text-gray-700">
                                    {preview.preview}
                                </div>
                            </div>
                        ) : (
                            <div className="text-center py-8">
                                <div className="loading-spinner mx-auto mb-4"></div>
                                <p className="text-gray-600">Generating preview...</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        );

        // Standings View Component - FIXED
        const StandingsView = ({ managers }) => {
            const sortedManagers = Utils.sortBy(managers, m => -m.wins, m => -parseFloat(m.pointsFor));
            
            return (
                <div className="max-w-4xl mx-auto">
                    <div className="bg-white rounded-xl shadow-lg overflow-hidden">
                        <div className="bg-gradient-to-r from-purple-600 to-pink-600 text-white p-4">
                            <h2 className="text-xl font-bold">League Standings</h2>
                        </div>
                        <div className="overflow-x-auto">
                            <table className="w-full">
                                <thead className="bg-gray-50 border-b">
                                    <tr>
                                        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Rank</th>
                                        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Team</th>
                                        <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Manager</th>
                                        <th className="px-4 py-3 text-center text-xs font-medium text-gray-500 uppercase">Record</th>
                                        <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 uppercase">Points For</th>
                                        <th className="px-4 py-3 text-center text-xs font-medium text-gray-500 uppercase">Streak</th>
                                        <th className="px-4 py-3 text-center text-xs font-medium text-gray-500 uppercase">Playoff</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-gray-200">
                                    {sortedManagers.map((manager, index) => (
                                        <tr key={manager.roster_id} className="hover:bg-gray-50 transition-colors">
                                            <td className="px-4 py-3 text-sm font-medium text-gray-900">
                                                {index + 1}
                                            </td>
                                            <td className="px-4 py-3 text-sm text-gray-900">
                                                {manager.teamName}
                                            </td>
                                            <td className="px-4 py-3 text-sm text-gray-500">
                                                {manager.display_name}
                                            </td>
                                            <td className="px-4 py-3 text-sm text-center text-gray-900">
                                                {manager.record}
                                            </td>
                                            <td className="px-4 py-3 text-sm text-right text-gray-900">
                                                {manager.pointsFor}
                                            </td>
                                            <td className="px-4 py-3 text-sm text-center">
                                                {manager.currentStreak > 0 && (
                                                    <span className={`inline-flex px-2 py-1 text-xs rounded-full ${
                                                        manager.streakType === 'win' 
                                                            ? 'bg-green-100 text-green-800' 
                                                            : 'bg-red-100 text-red-800'
                                                    }`}>
                                                        {manager.currentStreak}{manager.streakType === 'win' ? 'W' : 'L'}
                                                    </span>
                                                )}
                                            </td>
                                            <td className="px-4 py-3 text-sm text-center">
                                                <span className={`inline-flex px-2 py-1 text-xs rounded-full ${
                                                    manager.playoffPosition === 'in' 
                                                        ? 'bg-green-100 text-green-800'
                                                        : manager.playoffPosition === 'bubble'
                                                        ? 'bg-yellow-100 text-yellow-800'
                                                        : 'bg-gray-100 text-gray-800'
                                                }`}>
                                                    {manager.playoffPosition.toUpperCase()}
                                                </span>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            );
        };

        // Transactions View Component
        const TransactionsView = ({ transactions, players }) => {
            const recentTxns = transactions.slice(0, 20);
            
            return (
                <div className="max-w-4xl mx-auto space-y-4">
                    <div className="bg-white rounded-xl shadow-lg overflow-hidden">
                        <div className="bg-gradient-to-r from-green-600 to-blue-600 text-white p-4">
                            <h2 className="text-xl font-bold">Recent Transactions</h2>
                        </div>
                        <div className="divide-y divide-gray-200">
                            {recentTxns.length > 0 ? (
                                recentTxns.map((txn, index) => (
                                    <div key={index} className="p-4 hover:bg-gray-50 transition-colors">
                                        <div className="flex justify-between items-start">
                                            <div className="flex-1">
                                                <p className="text-sm font-medium text-gray-900">
                                                    Week {txn.leg} • {txn.type}
                                                </p>
                                                {txn.adds && Object.keys(txn.adds).length > 0 && (
                                                    <div className="mt-1">
                                                        <span className="text-xs text-green-600 font-medium">Added: </span>
                                                        {Object.keys(txn.adds).map(playerId => (
                                                            <span key={playerId} className="text-xs text-gray-600">
                                                                {players[playerId]?.full_name || playerId}
                                                            </span>
                                                        )).reduce((prev, curr) => [prev, ', ', curr])}
                                                    </div>
                                                )}
                                                {txn.drops && Object.keys(txn.drops).length > 0 && (
                                                    <div className="mt-1">
                                                        <span className="text-xs text-red-600 font-medium">Dropped: </span>
                                                        {Object.keys(txn.drops).map(playerId => (
                                                            <span key={playerId} className="text-xs text-gray-600">
                                                                {players[playerId]?.full_name || playerId}
                                                            </span>
                                                        )).reduce((prev, curr) => [prev, ', ', curr])}
                                                    </div>
                                                )}
                                            </div>
                                            <div className="text-right">
                                                <p className="text-xs text-gray-500">
                                                    {new Date(txn.created).toLocaleDateString()}
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                ))
                            ) : (
                                <div className="p-8 text-center text-gray-500">
                                    No recent transactions
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // Insights View Component (placeholder for future features)
        const InsightsView = ({ leagueData }) => (
            <div className="max-w-6xl mx-auto">
                <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
                    {/* Power Rankings Card */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h3 className="text-lg font-bold text-gray-800 mb-4">Power Rankings</h3>
                        <p className="text-gray-600 text-sm">Coming soon...</p>
                    </div>
                    
                    {/* Trade Analyzer Card */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h3 className="text-lg font-bold text-gray-800 mb-4">Trade Analyzer</h3>
                        <p className="text-gray-600 text-sm">Coming soon...</p>
                    </div>
                    
                    {/* Season Trends Card */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h3 className="text-lg font-bold text-gray-800 mb-4">Season Trends</h3>
                        <p className="text-gray-600 text-sm">Coming soon...</p>
                    </div>
                    
                    {/* MVP Tracker Card */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h3 className="text-lg font-bold text-gray-800 mb-4">MVP Tracker</h3>
                        <p className="text-gray-600 text-sm">Coming soon...</p>
                    </div>
                    
                    {/* Waiver Wire Targets Card */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h3 className="text-lg font-bold text-gray-800 mb-4">Waiver Wire Targets</h3>
                        <p className="text-gray-600 text-sm">Coming soon...</p>
                    </div>
                    
                    {/* Playoff Scenarios Card */}
                    <div className="bg-white rounded-xl shadow-lg p-6">
                        <h3 className="text-lg font-bold text-gray-800 mb-4">Playoff Scenarios</h3>
                        <p className="text-gray-600 text-sm">Coming soon...</p>
                    </div>
                </div>
            </div>
        );

        // Matchups View Component
        const MatchupsView = ({ games, onSelectGame, generatingPreview }) => (
            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
                {games.map(game => (
                    <MatchupCard
                        key={game.id}
                        game={game}
                        onSelect={onSelectGame}
                        isGenerating={generatingPreview === game.id}
                    />
                ))}
            </div>
        );

        // ============================================
        // PREVIEW GENERATOR SERVICE
        // ============================================
        class PreviewGenerator {
            static async generateMatchupPreview(game, leagueData) {
                const prompt = this.buildPrompt(game, leagueData);
                
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [{
                                role: 'system',
                                content: 'You are a fantasy football analyst writing engaging matchup previews. Use only the provided Sleeper API data. Structure your analysis in three sections: MATCHUP PREVIEW, PLAYERS TO WATCH, and PREDICTION.'
                            }, {
                                role: 'user',
                                content: prompt
                            }],
                            temperature: 0.85,
                            max_tokens: 1200
                        })
                    });

                    if (!response.ok) throw new Error(`API error: ${response.status}`);
                    
                    const data = await response.json();
                    return JSON.parse(data.choices[0].message.content);
                } catch (error) {
                    console.error('Error generating preview:', error);
                    throw error;
                }
            }

            static buildPrompt(game, leagueData) {
                let prompt = `WEEK ${leagueData.currentWeek} MATCHUP PREVIEW\n\n`;
                prompt += `${game.team1.teamName} (${game.team1.record}) vs ${game.team2.teamName} (${game.team2.record})\n\n`;
                
                // Add roster information
                ['team1', 'team2'].forEach(team => {
                    const teamData = game[team];
                    prompt += `${teamData.manager}'s Lineup:\n`;
                    
                    if (teamData.starters.length > 0) {
                        const byPosition = Utils.groupBy(teamData.starters, 'position');
                        Object.entries(byPosition).forEach(([pos, players]) => {
                            prompt += `${pos}: ${players.map(p => p.name).join(', ')}\n`;
                        });
                    } else {
                        prompt += `Lineup not yet set\n`;
                    }
                    prompt += '\n';
                });
                
                prompt += `\nWrite a 400+ word analysis with three sections: MATCHUP PREVIEW, PLAYERS TO WATCH, and PREDICTION.\n`;
                prompt += `Return JSON: {"preview": "your full analysis"}`;
                
                return prompt;
            }
        }

        // ============================================
        // MAIN APP COMPONENT
        // ============================================
        function FantasyFootballApp() {
            const { data: leagueData, loading, error, loadingStatus, refetch } = useLeagueData();
            const [activeView, setActiveView] = React.useState('matchups');
            const [selectedMatchup, setSelectedMatchup] = React.useState(null);
            const [staticPreviews, setStaticPreviews] = React.useState({});
            const [previewsLoading, setPreviewsLoading] = React.useState(true);

            // Load static previews on mount
            React.useEffect(() => {
                const loadPreviews = async () => {
                    setPreviewsLoading(true);
                    const previews = await PreviewLoader.loadStaticPreviews();
                    setStaticPreviews(previews);
                    setPreviewsLoading(false);
                };
                
                if (leagueData) {
                    loadPreviews();
                }
            }, [leagueData]);

            const handleSelectMatchup = async (game) => {
                let preview;
                
                // Check if we have a static preview
                if (staticPreviews[game.id]) {
                    preview = staticPreviews[game.id];
                } else {
                    // Fallback to generated preview
                    console.log('Using fallback preview for game:', game.id);
                    preview = PreviewLoader.generateFallbackPreview(game, leagueData);
                }
                
                setSelectedMatchup({ ...game, preview });
            };

            // Handle loading state
            if (loading) {
                return <LoadingScreen status={loadingStatus} />;
            }

            // Handle error state
            if (error) {
                return <ErrorScreen error={error} onRetry={refetch} />;
            }

            // Main app render
            return (
                <div className="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-800">
                    <Navigation
                        activeView={activeView}
                        onViewChange={setActiveView}
                        leagueName={leagueData.league.name}
                        currentWeek={leagueData.currentWeek}
                    />

                    <div className="max-w-7xl mx-auto px-4 py-8">
                        {/* Show preview loading status */}
                        {previewsLoading && (
                            <div className="mb-4 text-center">
                                <div className="inline-flex items-center px-4 py-2 bg-white bg-opacity-20 rounded-lg text-white text-sm">
                                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                                    Loading matchup previews...
                                </div>
                            </div>
                        )}

                        {activeView === 'matchups' && (
                            <MatchupsView
                                games={leagueData.games}
                                onSelectGame={handleSelectMatchup}
                                generatingPreview={null} // No longer generating on-demand
                            />
                        )}

                        {activeView === 'standings' && (
                            <StandingsView managers={leagueData.managers} />
                        )}

                        {activeView === 'transactions' && (
                            <TransactionsView 
                                transactions={leagueData.transactions}
                                players={leagueData.players}
                            />
                        )}

                        {activeView === 'insights' && (
                            <InsightsView leagueData={leagueData} />
                        )}
                    </div>

                    {/* Preview status indicator */}
                    {!previewsLoading && (
                        <div className="fixed bottom-4 right-4 z-30">
                            <div className="bg-black bg-opacity-60 text-white px-3 py-1 rounded-full text-xs">
                                {Object.keys(staticPreviews).length > 0 ? (
                                    <span className="text-green-400">✓ AI Previews Loaded</span>
                                ) : (
                                    <span className="text-yellow-400">⚠ Using Fallback Previews</span>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Matchup Modal */}
                    {selectedMatchup && (
                        <MatchupModal
                            game={selectedMatchup}
                            preview={selectedMatchup.preview}
                            onClose={() => setSelectedMatchup(null)}
                        />
                    )}
                </div>
            );
        }

        // ============================================
        // RENDER APP
        // ============================================
        ReactDOM.render(<FantasyFootballApp />, document.getElementById('root'));
    </script>
</body>
</html>
